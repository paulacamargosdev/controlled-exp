# Relatório final: GraphQL vs REST

## Introdução

A linguagem de consulta GraphQL, proposta pelo Facebook como metodologia de implementação de APIs Web, representa uma alternativa às populares APIs REST. Baseada em grafos, a linguagem permite que usuários consultem banco de dados na forma de schemas, de modo que se possa exportar a base e realizar consultas num formato definido pelo fornecedor da API. Por outro lado, APIs criadas com base em abordagens REST baseiam-se em endpoints: operações pré-definidas que podem ser chamadas por clientes que desejam consultar, deletar, atualizar ou escrever um dado na base. Desde o seu surgimento, vários sistemas realizaram a migração entre ambas as soluções, mantendo soluções compatíveis REST, mas oferecendo os benefícios da nova linguagem de consulta proposta. Entretanto, não está claro quais os reais benefícios da adoção de uma API GraphQL em detrimento de uma API REST.

Nesse contexto, o objetivo deste laboratório é realizar um experimento controlado para avaliar quantitativamente os benefícios da adoção de uma API GraphQL. Especificamente, as seguintes perguntas devem ser respondidas: RQ1 - Respostas às consultas GraphQL são mais rápidas que respostas às consultas REST? RQ2 - Respostas às consultas GraphQL têm tamanho menor que respostas às consultas REST?

Para responder a essas perguntas, foram formuladas hipóteses estatísticas específicas. Para a primeira pergunta de pesquisa (RQ1), a hipótese nula (H0₁) estabelece que não há diferença significativa no tempo de resposta entre consultas GraphQL e consultas REST, ou seja, μ_GraphQL = μ_REST. A hipótese alternativa (H1₁) postula que consultas GraphQL apresentam tempo de resposta significativamente menor que consultas REST, expressa como μ_GraphQL < μ_REST. Para a segunda pergunta de pesquisa (RQ2), a hipótese nula (H0₂) afirma que não há diferença significativa no tamanho da resposta entre consultas GraphQL e consultas REST, representada por μ_GraphQL = μ_REST. A hipótese alternativa (H1₂) propõe que consultas GraphQL apresentam tamanho de resposta significativamente menor que consultas REST, formulada como μ_GraphQL < μ_REST.

Estas hipóteses foram testadas através de um experimento controlado que comparou sistematicamente o desempenho de ambas as abordagens em diferentes cenários de uso, utilizando a API do GitHub que oferece ambas as interfaces.

## Metodologia

O experimento foi desenhado como um experimento fatorial completo 2×4, onde o primeiro fator representa o tipo de API com dois níveis (REST e GraphQL) e o segundo fator representa o tipo de consulta com quatro níveis (simples, relacionamentos, filtros e paginação). Este desenho resultou em oito tratamentos distintos, cada um sendo executado trinta vezes, totalizando duzentas e quarenta medições. A escolha de trinta repetições por tratamento foi fundamentada no Teorema do Limite Central, que permite a aplicação de testes paramétricos quando n ≥ 30, além de fornecer poder estatístico adequado para detectar diferenças significativas de tamanho médio.

As variáveis dependentes medidas foram o tempo de resposta em milissegundos e o tamanho da resposta em bytes. O tempo de resposta foi medido utilizando a função time.perf_counter() do Python, que captura o tempo decorrido desde o envio da requisição até o recebimento completo da resposta. O tamanho da resposta foi medido através da função len() aplicada ao conteúdo da resposta HTTP, retornando o tamanho total do payload em bytes. As variáveis independentes manipuladas foram o tipo de API (REST ou GraphQL) e o tipo de consulta (simples, relacionamentos, filtros ou paginação).

O objeto experimental escolhido foi a API do GitHub, que oferece tanto a interface REST (versão 3) quanto a interface GraphQL (versão 4). Esta escolha foi justificada pela disponibilidade de ambas as versões na mesma plataforma, garantindo comparabilidade, pela excelente documentação disponível, pela alta disponibilidade e confiabilidade do serviço, e pela possibilidade de realizar consultas de diferentes complexidades com dados reais e consistentes.

Os oito tratamentos implementados foram os seguintes: T1 consistiu em consultas REST simples através do endpoint GET /users/{username}; T2 correspondeu a consultas GraphQL simples através da query { user(login: "...") { ... } }; T3 envolveu consultas REST com relacionamentos, requerendo duas requisições separadas (GET /users/{username} e GET /users/{username}/repos); T4 implementou consultas GraphQL com relacionamentos em uma única query que obtém dados relacionados; T5 realizou consultas REST com filtros através do endpoint GET /search/repositories?q=...; T6 executou consultas GraphQL equivalentes com filtros; T7 aplicou consultas REST com paginação usando parâmetros per_page e page; T8 implementou consultas GraphQL com paginação utilizando o argumento first.

A ordem de execução dos tratamentos foi randomizada para evitar efeitos de ordem que poderiam introduzir viés nos resultados. Entre cada requisição, foi implementado um intervalo de um segundo para evitar rate limiting da API. Todas as requisições foram autenticadas utilizando um token de acesso pessoal do GitHub, o que aumenta o limite de requisições permitidas e garante acesso consistente aos dados.

O ambiente de execução consistiu em um sistema operacional Windows 11, utilizando Python versão 3.13.0. As bibliotecas principais utilizadas foram requests versão 2.32.5 para realizar as requisições HTTP, pandas versão 2.3.2 para manipulação de dados, scipy versão 1.16.1 para testes estatísticos, statsmodels versão 0.14.5 para análise de variância, e matplotlib versão 3.10.3 e seaborn versão 0.13.2 para geração de visualizações.

A análise estatística foi conduzida seguindo uma abordagem sistemática. Primeiro, foram calculadas estatísticas descritivas para cada grupo experimental, incluindo média, desvio padrão, mínimo, mediana e máximo. Em seguida, foram realizados testes de premissas: o teste de Shapiro-Wilk foi aplicado para verificar normalidade dos dados, e o teste de Levene foi utilizado para verificar homogeneidade de variâncias. Como nenhum dos dezesseis grupos testados apresentou distribuição normal (p < 0.05 em todos os casos), optou-se pelo uso de testes não-paramétricos como abordagem principal. O teste de Mann-Whitney U foi escolhido como teste principal para comparar REST e GraphQL, com nível de significância α = 0.05. O teste t de Student foi mantido para fins comparativos, e uma análise de variância bidirecional (ANOVA) foi aplicada para investigar interações entre os fatores. O tamanho de efeito foi calculado utilizando Cohen's d para quantificar a magnitude prática das diferenças observadas.

## Resultados

A execução do experimento resultou em duzentas e quarenta medições, todas bem-sucedidas, representando uma taxa de sucesso de 100%. A distribuição das medições foi balanceada, com trinta medições para cada uma das oito combinações de tratamento (quatro tipos de consulta × dois tipos de API).

Para a primeira pergunta de pesquisa (RQ1), que investiga se respostas às consultas GraphQL são mais rápidas que respostas às consultas REST, os resultados revelaram que, considerando todas as medições combinadas, a API REST apresentou tempo médio de resposta de 448,38 milissegundos com desvio padrão de 241,44 milissegundos, enquanto a API GraphQL apresentou tempo médio de 520,73 milissegundos com desvio padrão de 202,39 milissegundos. A diferença observada foi de -72,35 milissegundos, indicando que GraphQL foi, em média, mais lento que REST, contrariamente à hipótese alternativa. O teste de Mann-Whitney U resultou em uma estatística U de 8724,00 com p-value de 0,9977, valor muito superior ao nível de significância de 0,05. O teste t de Student independente resultou em t = 2,5157 com p-value de 0,9937. O tamanho de efeito calculado (Cohen's d) foi de 0,3248, indicando um efeito pequeno. Com base nesses resultados, a hipótese nula H0₁ não pode ser rejeitada, e conclui-se que não há diferença estatisticamente significativa no tempo de resposta entre GraphQL e REST.

A Figura 1 apresenta box plots comparando o tempo de resposta entre REST e GraphQL, organizados por tipo de consulta. Os gráficos revelam a distribuição dos tempos de resposta, incluindo quartis, mediana e valores extremos, permitindo visualizar a variabilidade e as diferenças entre as abordagens. O gráfico à esquerda mostra a comparação por tipo de consulta, enquanto o gráfico à direita apresenta a comparação geral entre as duas APIs.

![Box Plots - Tempo de Resposta](results/visualizations/boxplot_response_time.png)

**Figura 1: Box Plots Comparando Tempo de Resposta entre REST e GraphQL**

A Figura 2 apresenta box plots comparando o tamanho da resposta entre REST e GraphQL, também organizados por tipo de consulta. Estes gráficos demonstram visualmente a dramática diferença no tamanho das respostas, com GraphQL apresentando valores consistentemente menores em todos os tipos de consulta. A escala logarítmica implícita na visualização torna evidente a magnitude da redução alcançada pelo GraphQL.

![Box Plots - Tamanho da Resposta](results/visualizations/boxplot_response_size.png)

**Figura 2: Box Plots Comparando Tamanho da Resposta entre REST e GraphQL**

A Figura 3 apresenta gráficos de barras com intervalos de confiança de 95% para ambas as métricas. O gráfico superior compara o tempo médio de resposta entre REST e GraphQL por tipo de consulta, incluindo barras de erro que representam o erro padrão da média multiplicado por 1,96. O gráfico inferior apresenta a mesma comparação para tamanho da resposta. Estes gráficos facilitam a comparação direta das médias e a visualização da incerteza associada a cada estimativa.

![Gráficos de Barras com Intervalos de Confiança](results/visualizations/barplot_comparison.png)

**Figura 3: Gráficos de Barras Comparando Médias com Intervalos de Confiança (95%)**

Quando analisado por tipo de consulta, os resultados mostraram padrões variados. Para consultas simples, REST apresentou tempo médio de 244,18 milissegundos enquanto GraphQL apresentou 291,56 milissegundos, com diferença de -47,38 milissegundos e p-value de 1,0000 no teste de Mann-Whitney U, indicando ausência de diferença significativa. Para consultas com relacionamentos, REST apresentou 532,71 milissegundos e GraphQL 527,74 milissegundos, com diferença de +4,97 milissegundos a favor do GraphQL, mas com p-value de 0,0687, ainda acima do nível de significância. Para consultas com filtros, REST apresentou 726,71 milissegundos e GraphQL 767,58 milissegundos, com diferença de -40,87 milissegundos e p-value de 0,9957. Para consultas com paginação, REST apresentou 289,91 milissegundos e GraphQL 496,03 milissegundos, com diferença de -206,12 milissegundos e p-value de 1,0000. Em nenhum dos tipos de consulta individuais houve diferença estatisticamente significativa, embora a magnitude das diferenças tenha variado substancialmente.

A análise de variância bidirecional para tempo de resposta revelou efeitos significativos tanto do tipo de API (F = 18,94, p < 0,0001) quanto do tipo de consulta (F = 152,45, p < 0,0001), além de uma interação significativa entre esses fatores (F = 7,69, p < 0,0001). Esta interação indica que o desempenho relativo entre REST e GraphQL varia dependendo do tipo de consulta realizada, sugerindo que a escolha entre as abordagens deve considerar o contexto específico de uso.

A Tabela 1 apresenta os resultados dos testes estatísticos para a primeira pergunta de pesquisa (RQ1), comparando tempo de resposta entre REST e GraphQL. Os resultados são apresentados tanto para a análise geral quanto para cada tipo de consulta individualmente, incluindo médias, desvios padrão, diferenças observadas, estatísticas dos testes e valores de p.

**Tabela 1: Análise Estatística RQ1 - Tempo de Resposta (ms)**

| Tipo de Consulta | REST Média | REST DP | GraphQL Média | GraphQL DP | Diferença | Teste t | p-value (t) | Mann-Whitney U | p-value (U) | Cohen's d | Significativo? |
| ---------------- | ----------- | ------- | -------------- | ---------- | ---------- | ------- | ----------- | -------------- | ----------- | --------- | -------------- |
| GERAL            | 448,38      | 241,44  | 520,73         | 202,39     | -72,35     | 2,52    | 0,9937      | 8724,00        | 0,9977      | 0,32      | Não           |
| Simples          | 244,18      | 100,51  | 291,56         | 71,97      | -47,38     | 2,10    | 0,9799      | 782,00         | 1,0000      | 0,54      | Não           |
| Relacionamentos  | 532,71      | 53,21   | 527,74         | 127,63     | +4,97      | -0,20   | 0,4223      | 349,00         | 0,0687      | -0,05     | Não           |
| Filtros          | 726,71      | 255,59  | 767,58         | 133,18     | -40,87     | 0,78    | 0,7798      | 627,00         | 0,9957      | 0,20      | Não           |
| Paginação      | 289,91      | 65,82   | 496,03         | 104,10     | -206,12    | 9,17    | 1,0000      | 878,00         | 1,0000      | 2,37      | Não           |

Para a segunda pergunta de pesquisa (RQ2), que investiga se respostas às consultas GraphQL têm tamanho menor que respostas às consultas REST, os resultados foram dramaticamente diferentes. Considerando todas as medições combinadas, a API REST apresentou tamanho médio de resposta de 35.548,12 bytes com desvio padrão de 23.989,90 bytes, enquanto a API GraphQL apresentou tamanho médio de 2.439,16 bytes com desvio padrão de 1.245,66 bytes. A diferença observada foi de 33.108,97 bytes, representando uma redução percentual de 93,14% a favor do GraphQL. O teste de Mann-Whitney U resultou em uma estatística U de 3660,00 com p-value inferior a 0,0001, indicando diferença altamente significativa. O teste t de Student resultou em t = -15,0981 com p-value também inferior a 0,0001. O tamanho de efeito calculado (Cohen's d) foi de -1,9492, indicando um efeito muito grande. Com base nesses resultados, a hipótese nula H0₂ é rejeitada e a hipótese alternativa H1₂ é aceita, concluindo-se que GraphQL apresenta tamanho de resposta significativamente menor que REST.

A Figura 4 apresenta histogramas das distribuições para ambas as métricas e ambas as APIs. Os quatro gráficos mostram a forma das distribuições dos dados coletados, permitindo verificar visualmente características como assimetria, presença de outliers e concentração de valores. Os histogramas confirmam que as distribuições não seguem padrões normais, justificando o uso de testes não-paramétricos na análise estatística.

![Histogramas das Distribuições](results/visualizations/histograms_distribution.png)

**Figura 4: Histogramas das Distribuições de Tempo e Tamanho de Resposta**

A Figura 5 apresenta violin plots que combinam informações de box plots com estimativas de densidade de probabilidade. Estes gráficos fornecem uma visão mais completa das distribuições, mostrando não apenas os quartis e a mediana, mas também a forma completa da distribuição de probabilidade. Os violin plots são particularmente úteis para identificar modas múltiplas, assimetrias e a concentração relativa de valores em diferentes regiões da distribuição.

![Violin Plots das Distribuições](results/visualizations/violinplot_distributions.png)

**Figura 5: Violin Plots das Distribuições de Tempo e Tamanho de Resposta**

A análise por tipo de consulta confirmou que a vantagem do GraphQL em termos de tamanho de resposta é consistente e robusta em todos os cenários testados. Para consultas simples, REST apresentou tamanho médio de 1.246,87 bytes enquanto GraphQL apresentou 414,10 bytes, representando redução de 66,79% com p-value inferior a 0,0001. Para consultas com relacionamentos, REST apresentou 50.251,50 bytes e GraphQL 2.893,67 bytes, representando redução de 94,24% com p-value inferior a 0,0001. Para consultas com filtros, REST apresentou 55.825,77 bytes e GraphQL 3.635,23 bytes, representando redução de 93,49% com p-value inferior a 0,0001. Para consultas com paginação, REST apresentou 34.868,37 bytes e GraphQL 2.813,63 bytes, representando redução de 91,93% com p-value de 0,0009. Em todos os tipos de consulta, a diferença foi estatisticamente significativa, com a maior redução observada em consultas com relacionamentos e a menor, ainda assim substancial, em consultas simples.

A análise de variância bidirecional para tamanho da resposta revelou efeitos extremamente significativos do tipo de API (F = 1062,44, p < 0,0001) e do tipo de consulta (F = 162,39, p < 0,0001), além de uma interação muito forte entre esses fatores (F = 130,03, p < 0,0001). Esta interação indica que a magnitude da redução de tamanho varia substancialmente entre diferentes tipos de consulta, sendo mais pronunciada em consultas complexas que envolvem relacionamentos.

A Tabela 3 apresenta os resultados dos testes estatísticos para a segunda pergunta de pesquisa (RQ2), comparando tamanho de resposta entre REST e GraphQL. Além das estatísticas descritivas e dos testes, inclui a redução percentual observada, que demonstra claramente a vantagem do GraphQL em todos os cenários testados.

**Tabela 3: Análise Estatística RQ2 - Tamanho da Resposta (bytes)**

| Tipo de Consulta | REST Média | REST DP  | GraphQL Média | GraphQL DP | Diferença | Redução (%) | Teste t | p-value (t) | Mann-Whitney U | p-value (U) | Cohen's d | Significativo? |
| ---------------- | ----------- | -------- | -------------- | ---------- | ---------- | ------------- | ------- | ----------- | -------------- | ----------- | --------- | -------------- |
| GERAL            | 35548,12    | 23989,90 | 2439,16        | 1245,66    | 33108,97   | 93,14         | -15,10  | < 0,0001    | 3660,00        | < 0,0001    | -1,95     | Sim            |
| Simples          | 1246,87     | 38,43    | 414,10         | 28,61      | 832,77     | 66,79         | -95,19  | < 0,0001    | 0,00           | < 0,0001    | -24,58    | Sim            |
| Relacionamentos  | 50251,50    | 4170,51  | 2893,67        | 250,78     | 47357,83   | 94,24         | -62,08  | < 0,0001    | 0,00           | < 0,0001    | -16,03    | Sim            |
| Filtros          | 55825,77    | 1763,59  | 3635,23        | 415,37     | 52190,53   | 93,49         | -157,77 | < 0,0001    | 0,00           | < 0,0001    | -40,74    | Sim            |
| Paginação      | 34868,37    | 21782,14 | 2813,63        | 223,65     | 32054,73   | 91,93         | -8,06   | < 0,0001    | 240,00         | 0,0009      | -2,08     | Sim            |

## Discussão

A primeira pergunta de pesquisa, que investigava se GraphQL seria mais rápido que REST, foi respondida negativamente. Não apenas não há evidência estatística de que GraphQL seja mais rápido, mas os dados sugerem que REST pode ser ligeiramente mais rápido, embora essa diferença não seja estatisticamente significativa.

Várias explicações podem ser oferecidas para este achado. Primeiro, a API REST do GitHub é extremamente madura e otimizada, tendo sido desenvolvida e refinada ao longo de muitos anos. Em contraste, a API GraphQL do GitHub, embora robusta, pode ter overhead adicional relacionado ao processamento de queries, resolução de campos e gerenciamento de relacionamentos. Segundo, o processamento de queries GraphQL requer parsing e execução de uma query estruturada, o que pode adicionar latência no servidor comparado a endpoints REST pré-definidos e altamente otimizados. Terceiro, APIs REST podem se beneficiar mais de estratégias de cache HTTP tradicionais, que são amplamente suportadas por proxies e CDNs. Quarto, a complexidade adicional do GraphQL, que permite consultas altamente customizadas, pode introduzir overhead computacional que compensa os benefícios teóricos.

Em consultas com relacionamentos, GraphQL foi marginalmente mais rápido (diferença de 4,97 milissegundos). Isto sugere que quando múltiplos endpoints REST precisam ser chamados sequencialmente, o GraphQL pode oferecer alguma vantagem ao consolidar essas requisições em uma única query. No entanto, em consultas com paginação, REST foi substancialmente mais rápido (diferença de 206 milissegundos), possivelmente devido a otimizações específicas do endpoint REST para paginação. A interação significativa detectada na ANOVA confirma que o desempenho relativo entre as abordagens depende criticamente do tipo de consulta realizada.

A segunda pergunta de pesquisa, que investigava se GraphQL produz respostas menores, foi respondida afirmativamente. A redução de 93,14% no tamanho médio das respostas representa um resultado extremamente significativo tanto estatisticamente quanto praticamente. Este achado confirma uma das principais alegações sobre os benefícios do GraphQL e tem implicações importantes para aplicações reais.

A magnitude desta redução pode ser explicada por várias características fundamentais do GraphQL. Primeiro, GraphQL permite que o cliente especifique exatamente quais campos deseja receber, eliminando o problema de over-fetching que é comum em APIs REST, onde endpoints retornam objetos completos com muitos campos que podem não ser necessários para uma aplicação específica. Segundo, a estrutura de dados retornada pelo GraphQL tende a ser mais enxuta, sem metadados desnecessários ou campos redundantes. Terceiro, GraphQL permite consultar dados relacionados em uma única requisição de forma eficiente, evitando a necessidade de múltiplas requisições REST que podem resultar em dados duplicados ou excessivos. Quarto, o controle granular sobre os dados solicitados permite otimizações no lado do servidor que reduzem o tamanho total da resposta.

Mesmo em consultas simples, GraphQL ainda produziu respostas 66,79% menores. Em consultas mais complexas envolvendo relacionamentos, a redução alcançou 94,24%, demonstrando que os benefícios do GraphQL se tornam mais pronunciados conforme a complexidade da consulta aumenta.

As implicações práticas destes resultados são substanciais. Para aplicações móveis, onde economia de banda é crítica devido a planos de dados limitados e custos de transferência, a redução de 93% no tamanho das respostas pode resultar em economia significativa de custos e melhor experiência do usuário. Para aplicações que servem muitos clientes simultaneamente, a redução no tráfego de rede pode resultar em menor carga nos servidores e menor latência percebida pelos usuários, especialmente em conexões mais lentas. Para APIs que cobram baseado em volume de dados transferidos, a economia pode ser financeiramente significativa.

Apesar dos beneficios, é importante reconhecer que há um trade-off evidente entre tempo de resposta e tamanho de resposta. Enquanto GraphQL oferece respostas dramaticamente menores, ele não oferece vantagem em termos de velocidade, e pode até ser ligeiramente mais lento em alguns cenários. Esta observação sugere que a decisão entre REST e GraphQL deve considerar as prioridades específicas da aplicação. Se latência mínima é crítica e o tamanho das respostas não é uma preocupação primária, REST pode ser preferível. Se economia de banda, eficiência de transferência e flexibilidade nas consultas são prioritárias, GraphQL oferece benefícios claros e mensuráveis.

As interações significativas detectadas nas análises de variância para ambas as métricas indicam que o desempenho relativo entre REST e GraphQL não é uniforme, mas varia dependendo do tipo de consulta realizada. Por exemplo, consultas simples e frequentes que requerem latência mínima podem ser implementadas via REST, enquanto consultas complexas que envolvem múltiplos relacionamentos e onde economia de banda é importante podem ser implementadas via GraphQL.

Os resultados fornecem evidência quantitativa valiosa sobre as diferenças entre GraphQL e REST. A redução de 93% no tamanho das respostas é um achado robusto e consistente que tem implicações práticas claras. A ausência de diferença significativa em tempo de resposta, embora contrária à expectativa inicial, fornece informação importante para tomadores de decisão que devem considerar trade-offs entre diferentes métricas de desempenho.